set package [lindex $argv 0]

proc k {a args} { return $a }

proc shift varName {
  upvar 1 $varName var
  k [lindex $var 0] [set var [lrange $var 1 end]]  
}

# Parse input and record info.
while {[gets stdin buf] >= 0} {
  set line [string trim $buf]    ;# Trim.
  regsub {[#].*$} $line "" line  ;# Delete comments
  if { $line eq "" } continue

  if [regexp {define\s+(\w+)\s+(extends\s+(\w+)\s+)?[=]\s+(\d+)} $line _ cls _ super clsnum] {
    set Classes($cls) $clsnum
    set Extends($cls) $super
  } elseif [regexp {(repeated\s+)?(\w+)\s+(\w+)\s+[=]\s+(\d+)} $line _ rep type field number] {
    set repeat [string length $rep]
    lappend Fields($cls) $field
    set Type($cls,$field) $type
    set Repeat($cls,$field) $repeat
    set Number($cls,$field) $number
  } else {
    error "Syntax Error on this line: '$line'"
  }
}

# Extend inherited classes.
foreach cls [array names Classes] {
  set c $cls
  puts "// START WITH CLASS $c"
  set e $Extends($c)
  while {[string length $e]} {
    puts "//   Extends $e"
    foreach f $Fields($e) {
      puts "//       Field: $f"
      lappend Fields($cls) $f
      set Inherited($cls,$f) 1
      set Type($cls,$f) $Type($e,$f)
      set Repeat($cls,$f) $Repeat($e,$f)
      set Number($cls,$f) $Number($e,$f)
    }
    set c $e
    set e $Extends($c)
  }
}

proc CmpFieldNumbers {cls f1 f2} {
  expr { $::Number($cls,$f1) > $::Number($cls,$f2) }
}

puts "// DO NOT EDIT THIS FILE.  It is generated from protocol.txt by compile-proto.tcl.

package $package;

import java.util.ArrayList;
import yak.etc.Bytes;
import yak.etc.Yak;

public abstract class Proto extends Yak {

  public abstract int classId();
  public abstract Bytes pickle();
"
foreach cls [lsort [array names Classes]] {
  puts "  public static final int Id$cls = $Classes($cls);"
}
puts ""

# Define the classes.
foreach cls [lsort [array names Classes]] {
  if [string length $Extends($cls)] {
    puts "  public static class $cls extends $Extends($cls) {  // = $Classes($cls)" ;#"}"
  } else {
    puts "  public static class $cls extends Proto {  // = $Classes($cls)" ;#"}"
  }
  foreach f [lsort -unique $Fields($cls)] {
    if ![info exists Inherited($cls,$f)] {
      set t $Type($cls,$f)
      if $Repeat($cls,$f) {
        puts "    ArrayList<$t> $f = new ArrayList<$t>();  // = $Number($cls,$f)"
      } else {
        puts "    $t $f;  // = $Number($cls,$f)"
      }
    }
  }
  puts "    public int classId() { return $Classes($cls); }"
  puts "    public String toString() {"
  puts "      StringBuilder sb = new StringBuilder(\"{\");"
  foreach f [lsort -unique $Fields($cls)] {
    set t $Type($cls,$f)
    if $Repeat($cls,$f) {
      puts "        for (int i = 0; i < $f.size(); ++i) {"
      puts "          $t x = $f.get(i);"
      puts "        sb.append(\" $f: \" + "
      switch $t {
	    int { 
		  puts "          x"
	    }
	    String { 
		  puts "          (x == null ? \"null\" :CurlyEncode(x))"
	    }
	    default { 
		  puts "          (x == null ? \"null\" : $f.toString())"
	    }
      }
      puts "        );"
      puts "        }"
    } else {
      puts "        sb.append(\" $f: \" + "
      switch $t {
	    int { 
		  puts "          $f"
	    }
	    String { 
		  puts "          ($f == null ? \"null\" :CurlyEncode($f))"
	    }
	    default { 
		  puts "          ($f == null ? \"null\" : $f.toString())"
	    }
      }
      puts "        );"
    }
  }
  puts "      sb.append(\"}\");"
  puts "      return sb.toString();"
  puts "    }"

  # Define the Pickle function.
  puts "  public Bytes pickle () {  // = $Classes($cls)"
  puts "    Bytes b = new Bytes();"
  puts "    b.appendProtoInt (0, $Classes($cls));  // Class Id $Classes($cls)"
  foreach f [lsort -command "CmpFieldNumbers $cls" [lsort -unique $Fields($cls)]] {
    set t $Type($cls,$f)
    if $Repeat($cls,$f) {
      # Repeated
      puts "      for (int i = 0; i < this.$f.size(); i++) {"
      switch $t {
	    int { 
		  puts "        b.appendProtoInt ($Number($cls,$f), this.$f.get(i));"
	    }
	    String { 
		  puts "        b.appendProtoString ($Number($cls,$f), this.$f.get(i));"
	    }
	    default { 
		  puts "        if (this.$f.get(i) != null) {
	      b.appendProtoBytes ($Number($cls,$f), this.$f.get(i).pickle());
        }"
	    }
	  }
	  puts "      } // next i"
	} else {
	  # Not repeated
      switch $t {
	    int { 
		  puts "    b.appendProtoInt ($Number($cls,$f), this.$f);"
	    }
	    String { 
		  puts "    if (this.$f != null) b.appendProtoString ($Number($cls,$f), this.$f);"
	    }
	    default { 
		  puts "    if (this.$f != null) {
	  b.appendProtoBytes ($Number($cls,$f), this.$f.pickle());
}"
	    }
	  }
	}
  }
  puts "    return b;"
  puts "  }"
  puts ""
  # "{"
  puts "  }"
  puts ""
}



# Define the Unpickle functions.
foreach cls [lsort [array names Classes]] {
  puts "public static $cls Unpickle$cls (Bytes b) {  // = $Classes($cls)"
  puts "  System.err.printf(\"Unpickle$cls: %s\\n\", b.showProto());"
  puts "  $cls z = new $cls ();"
  puts "  while (b.len > 0) {"
  puts "    int code = b.popVarInt();"
  puts "    System.err.println(Fmt(\"Code %d:%d\", code >> 3, code & 7));"
  puts "    switch (code) {"
  foreach f [lsort -unique $Fields($cls)] {
    set t $Type($cls,$f)
    if $Repeat($cls,$f) {
	  # Repeated
      switch $t {
	    int { 
		  puts "      case ($Number($cls,$f) << 3) | 0: { z.$f.add(b.popVarInt()); }"
	    }
	    String { 
		  puts "      case ($Number($cls,$f) << 3) | 2: { z.$f.add(b.popVarString()); }"
	    }
	    default { 
		  puts "      case ($Number($cls,$f) << 3) | 2: {"
          puts "         Bytes b2 = b.popVarBytes();"
          puts "         $t p2 = Unpickle$t (b2);"
	      puts "         z.$f.add(p2);"
		  puts "      } // end case"
	    }
	  }
	} else {
	  # Not repeated
      switch $t {
	    int { 
		  puts "      case ($Number($cls,$f) << 3) | 0: { z.$f = b.popVarInt(); }"
	    }
	    String { 
		  puts "      case ($Number($cls,$f) << 3) | 2: { z.$f = b.popVarString(); }"
	    }
	    default { 
		  puts "      case ($Number($cls,$f) << 3) | 2: {"
          puts "         Bytes b2 = b.popVarBytes();"
          puts "         $t p2 = Unpickle$t (b2);"
	      puts "         z.$f = p2;"
		  puts "      } // end case"
	    }
	  } ;# end switch
	} ;# end if
	puts "        break;"
  } ;# end foreach f
  puts "      case 0:  {int clsid = b.popVarInt(); if (clsid != $Classes($cls)) { throw new RuntimeException(\"Bad clsid: \" + clsid); }}"
  puts "        break;"
  puts "      default:"
  puts "        // Some day, ignore extra fields.  For now, call it an error."
  puts "        throw new RuntimeException(\"Bad tag code in $cls: \" + code); "
  puts "    }  // end switch"
  puts "  }  // end while"
  puts "  return z;"
  puts "}  // end Unpickle $cls"
  puts ""
  puts ""
}

puts "  public static Proto Unpickle(Bytes b) {"
puts "    if (b.arr\[b.off] == 0) {"
puts "      int clsid = b.arr\[b.off + 1];  // HACK works for clsid < 128"
puts "      switch (clsid) {"
foreach cls [lsort [array names Classes]] {
  puts "        case $Classes($cls) : return Unpickle$cls (b);"
}
puts "      }"
puts "      throw new RuntimeException(\"Bad cls id in Proto.Unpickle: \" + clsid); "
puts "    }"
puts "    throw new RuntimeException(\"Missing cls id in Proto.Unpickle\");"
puts "  }"
puts ""
puts "}"
